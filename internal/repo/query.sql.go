// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteRefreshTokenWhereUUID = `-- name: DeleteRefreshTokenWhereUUID :exec
DELETE FROM refresh_tokens WHERE uuid = $1
`

// DeleteRefreshTokenWhereUUID deletes a refresh token by uuid
func (q *Queries) DeleteRefreshTokenWhereUUID(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRefreshTokenWhereUUID, uuid)
	return err
}

const deleteRefreshTokensWhereExpired = `-- name: DeleteRefreshTokensWhereExpired :one
WITH deleted AS (
  DELETE FROM refresh_tokens
  WHERE NOW() > expires_at
  RETURNING id, user_id, uuid, issued_at, expires_at, revoked
)
SELECT COUNT(*) AS deleted_count
FROM deleted
`

// DeleteRefreshTokensWhereExpired deletes al refresh tokens that have expired
func (q *Queries) DeleteRefreshTokensWhereExpired(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, deleteRefreshTokensWhereExpired)
	var deleted_count int64
	err := row.Scan(&deleted_count)
	return deleted_count, err
}

const insertRefreshToken = `-- name: InsertRefreshToken :one

INSERT INTO refresh_tokens (user_id, issued_at, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, uuid, issued_at, expires_at, revoked
`

type InsertRefreshTokenParams struct {
	UserID    int32              `json:"userId"`
	IssuedAt  pgtype.Timestamptz `json:"issuedAt"`
	ExpiresAt pgtype.Timestamptz `json:"expiresAt"`
}

// REFRESH TOKEN --
// InsertRefreshToken inserts a new refresh token
func (q *Queries) InsertRefreshToken(ctx context.Context, arg InsertRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, insertRefreshToken, arg.UserID, arg.IssuedAt, arg.ExpiresAt)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Uuid,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const insertRole = `-- name: InsertRole :one

INSERT INTO roles (name) VALUES ($1) RETURNING id, name, created_at, updated_at
`

// ROLE --
// InsertRole creates a new role
func (q *Queries) InsertRole(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRow(ctx, insertRole, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one

INSERT INTO users (username, email, password_hash)
VALUES ($1, $2, $3)
RETURNING id, username, email, password_hash, created_at, updated_at
`

type InsertUserParams struct {
	Username     string `json:"username"`
	Email        string `json:"email"`
	PasswordHash string `json:"passwordHash"`
}

// USER --
// InsertUser inserts a new user
func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, insertUser, arg.Username, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertUserRole = `-- name: InsertUserRole :one

INSERT INTO user_roles (user_id, role_id) VALUES ($1, $2) RETURNING id, user_id, role_id, created_at, updated_at
`

type InsertUserRoleParams struct {
	UserID int32 `json:"userId"`
	RoleID int32 `json:"roleId"`
}

// USER ROLE --
// InsertUserRole creates an association between user and roles
func (q *Queries) InsertUserRole(ctx context.Context, arg InsertUserRoleParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, insertUserRole, arg.UserID, arg.RoleID)
	var i UserRole
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectRefreshTokenByUUID = `-- name: SelectRefreshTokenByUUID :one
SELECT id, user_id, uuid, issued_at, expires_at, revoked FROM refresh_tokens WHERE uuid = $1 LIMIT 1
`

// SelectRefreshTokenByUUID finds a refresh token by uuid
func (q *Queries) SelectRefreshTokenByUUID(ctx context.Context, uuid pgtype.UUID) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, selectRefreshTokenByUUID, uuid)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Uuid,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
	)
	return i, err
}

const selectRoleWhereName = `-- name: SelectRoleWhereName :one
SELECT id, name, created_at, updated_at FROM roles WHERE name = $1 LIMIT 1
`

// SelectRoleWhereName finds a role by its name
func (q *Queries) SelectRoleWhereName(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRow(ctx, selectRoleWhereName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectRolesWhereUserID = `-- name: SelectRolesWhereUserID :many
SELECT r.id, r.name, r.created_at, r.updated_at
FROM users u
JOIN user_roles ur ON ur.user_id = u.id
JOIN roles r       ON r.id = ur.role_id
WHERE u.id = $1
`

// SelectRolesWhereUserID finds all roles that a user has through user_roles
func (q *Queries) SelectRolesWhereUserID(ctx context.Context, id int32) ([]Role, error) {
	rows, err := q.db.Query(ctx, selectRolesWhereUserID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserWhereEmail = `-- name: SelectUserWhereEmail :one
SELECT id, username, email, password_hash, created_at, updated_at FROM users WHERE email = $1 LIMIT 1
`

// SelectUserWhereEmail finds a user by email
func (q *Queries) SelectUserWhereEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, selectUserWhereEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectUserWhereId = `-- name: SelectUserWhereId :one
SELECT id, username, email, password_hash, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

// SelectUserWhereId finds a user by id
func (q *Queries) SelectUserWhereId(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, selectUserWhereId, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectUserWhereUsername = `-- name: SelectUserWhereUsername :one
SELECT id, username, email, password_hash, created_at, updated_at FROM users WHERE username = $1 LIMIT 1
`

// SelectUserWhereUsername finds a user by username
func (q *Queries) SelectUserWhereUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, selectUserWhereUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
